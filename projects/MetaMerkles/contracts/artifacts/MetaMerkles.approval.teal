#pragma version 10

// This TEAL was generated by TEALScript v0.92.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// addRoot(pay,byte[32],uint64)void
*abi_route_addRoot:
	// type: uint64
	txna ApplicationArgs 2
	btoi

	// hashedRoot: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (hashedRoot) for addRoot must be a byte[32]
	assert

	// pmt: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 2 (pmt) for addRoot must be a pay transaction
	assert

	// execute addRoot(pay,byte[32],uint64)void
	callsub addRoot
	int 1
	return

// addRoot(pmt: PayTxn, hashedRoot: bytes32, type: uint64): void
//
// Creates two boxes and adds a merkle root
// using a `RootKey` to the root box map and also a list type to the
// metadata attached to the root in the data box map
//
// @param pmt the fee to cover box storage allocation
// @param hashedRoot a sha256'd 32 byte merkle tree root
// @param type an index of the `RootType` enum of the type of the list
addRoot:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/MetaMerkles.algo.ts:46
	// key: RootKey = { address: this.txn.sender, root: hashedRoot }
	txn Sender
	frame_dig -2 // hashedRoot: bytes32
	concat
	frame_bury 0 // key: RootKey

	// contracts/MetaMerkles.algo.ts:47
	// dataKey: DataKey = this.getDataKey(this.txn.sender, hashedRoot, 'type')
	byte 0x74797065 // "type"
	frame_dig -2 // hashedRoot: bytes32
	txn Sender
	callsub getDataKey
	frame_bury 1 // dataKey: DataKey

	// contracts/MetaMerkles.algo.ts:49
	// assert(!this.roots(key).exists)
	frame_dig 0 // key: RootKey
	box_len
	swap
	pop
	!
	assert

	// contracts/MetaMerkles.algo.ts:50
	// assert(!this.data(dataKey).exists)
	frame_dig 1 // dataKey: DataKey
	box_len
	swap
	pop
	!
	assert

	// contracts/MetaMerkles.algo.ts:52
	// verifyPayTxn(pmt, {
	//       receiver: this.app.address,
	//       amount: rootMinBalance + dataTypeMinBalance,
	//     })
	// verify receiver
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pmt","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	int 48200
	==

	// transaction verification failed: {"txn":"pmt","field":"amount","expected":"rootMinBalance + dataTypeMinBalance"}
	assert

	// contracts/MetaMerkles.algo.ts:57
	// this.roots(key).create(0)
	frame_dig 0 // key: RootKey
	int 0
	box_create
	pop

	// contracts/MetaMerkles.algo.ts:58
	// this.data(dataKey).value = itob(type)
	frame_dig 1 // dataKey: DataKey
	dup
	box_del
	pop
	frame_dig -3 // type: uint64
	itob
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// deleteRoot(byte[32])void
*abi_route_deleteRoot:
	// hashedRoot: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (hashedRoot) for deleteRoot must be a byte[32]
	assert

	// execute deleteRoot(byte[32])void
	callsub deleteRoot
	int 1
	return

// deleteRoot(hashedRoot: bytes32): void
//
// Deletes the merkle root from the root box map
//
// @param hashedRoot the sha256'd 32 byte merkle tree root
deleteRoot:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/MetaMerkles.algo.ts:67
	// key: RootKey = { address: this.txn.sender, root: hashedRoot }
	txn Sender
	frame_dig -1 // hashedRoot: bytes32
	concat
	frame_bury 0 // key: RootKey

	// contracts/MetaMerkles.algo.ts:68
	// assert(this.roots(key).exists)
	frame_dig 0 // key: RootKey
	box_len
	swap
	pop
	assert

	// contracts/MetaMerkles.algo.ts:69
	// this.roots(key).delete()
	frame_dig 0 // key: RootKey
	box_del

	// contracts/MetaMerkles.algo.ts:72
	// sendPayment({
	//       receiver: this.txn.sender,
	//       amount: rootMinBalance,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/MetaMerkles.algo.ts:73
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/MetaMerkles.algo.ts:74
	// amount: rootMinBalance
	int 28100
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// addData(pay,byte[32],string,string)void
*abi_route_addData:
	// value: string
	txna ApplicationArgs 3
	extract 2 0

	// key: string
	txna ApplicationArgs 2
	extract 2 0

	// hashedRoot: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (hashedRoot) for addData must be a byte[32]
	assert

	// pmt: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 3 (pmt) for addData must be a pay transaction
	assert

	// execute addData(pay,byte[32],string,string)void
	callsub addData
	int 1
	return

// addData(pmt: PayTxn, hashedRoot: bytes32, key: string, value: string): void
//
// Registers a key & value in the data box map that
// corresponds to a merkle root in the root box map
//
// @param pmt the payment to cover the increased mbr of adding to box storage
// @param hashedRoot the sha256'd 32 byte merkle tree root
// @param key the metadata key eg. `Royalty`
// @param value the metadata value eg. `5` encoded as a bytestring for 5%
addData:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/MetaMerkles.algo.ts:88
	// rootKey: RootKey = { address: this.txn.sender, root: hashedRoot }
	txn Sender
	frame_dig -2 // hashedRoot: bytes32
	concat
	frame_bury 0 // rootKey: RootKey

	// contracts/MetaMerkles.algo.ts:90
	// assert(key.length <= 32, 'key length maximum is 32 bytes')
	frame_dig -3 // key: string
	len
	int 32
	<=

	// key length maximum is 32 bytes
	assert

	// contracts/MetaMerkles.algo.ts:91
	// assert(value.length <= 2048, 'max box size is 1KB')
	frame_dig -4 // value: string
	len
	int 2048
	<=

	// max box size is 1KB
	assert

	// contracts/MetaMerkles.algo.ts:92
	// assert(this.roots(rootKey).exists, 'there must be a root to associate the data to')
	frame_dig 0 // rootKey: RootKey
	box_len
	swap
	pop

	// there must be a root to associate the data to
	assert

	// contracts/MetaMerkles.algo.ts:94
	// verifyPayTxn(pmt, {
	//       receiver: this.app.address,
	//       amount: this.getBoxCreateMinBalance(32 + key.length, value.length),
	//     })
	// verify receiver
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pmt","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	frame_dig -4 // value: string
	len
	int 32
	frame_dig -3 // key: string
	len
	+
	callsub getBoxCreateMinBalance
	==

	// transaction verification failed: {"txn":"pmt","field":"amount","expected":"this.getBoxCreateMinBalance(32 + key.length, value.length)"}
	assert

	// contracts/MetaMerkles.algo.ts:99
	// dataKey: DataKey = this.getDataKey(this.txn.sender, hashedRoot, key)
	frame_dig -3 // key: string
	frame_dig -2 // hashedRoot: bytes32
	txn Sender
	callsub getDataKey
	frame_bury 1 // dataKey: DataKey

	// contracts/MetaMerkles.algo.ts:101
	// this.data(dataKey).value = value
	frame_dig 1 // dataKey: DataKey
	dup
	box_del
	pop
	frame_dig -4 // value: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// deleteData(byte[32],string)void
*abi_route_deleteData:
	// key: string
	txna ApplicationArgs 2
	extract 2 0

	// hashedRoot: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (hashedRoot) for deleteData must be a byte[32]
	assert

	// execute deleteData(byte[32],string)void
	callsub deleteData
	int 1
	return

// deleteData(hashedRoot: bytes32, key: string): void
//
// Deletes a metadata key & value pair from the data box map
//
// @param hashedRoot the sha256'd 32 byte merkle tree root
// @param key the metadata key you want to remove
deleteData:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/MetaMerkles.algo.ts:111
	// dataKey: DataKey = this.getDataKey(this.txn.sender, hashedRoot, key)
	frame_dig -2 // key: string
	frame_dig -1 // hashedRoot: bytes32
	txn Sender
	callsub getDataKey
	frame_bury 0 // dataKey: DataKey

	// contracts/MetaMerkles.algo.ts:113
	// assert(this.data(dataKey).exists)
	frame_dig 0 // dataKey: DataKey
	box_len
	swap
	pop
	assert

	// contracts/MetaMerkles.algo.ts:115
	// valueLength = this.data(dataKey).value.length
	frame_dig 0 // dataKey: DataKey
	box_get

	// box value does not exist: this.data(dataKey).value
	assert
	extract 2 0
	len
	frame_bury 1 // valueLength: uint64

	// contracts/MetaMerkles.algo.ts:117
	// this.data(dataKey).delete()
	frame_dig 0 // dataKey: DataKey
	box_del

	// contracts/MetaMerkles.algo.ts:119
	// sendPayment({
	//       receiver: this.txn.sender,
	//       amount: this.getBoxCreateMinBalance(32 + key.length, valueLength),
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/MetaMerkles.algo.ts:120
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/MetaMerkles.algo.ts:121
	// amount: this.getBoxCreateMinBalance(32 + key.length, valueLength)
	frame_dig 1 // valueLength: uint64
	int 32
	frame_dig -2 // key: string
	len
	+
	callsub getBoxCreateMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// verifyAsset(address,byte[32],string,uint64)bool
*abi_route_verifyAsset:
	// The ABI return prefix
	byte 0x151f7c75

	// verifyingAsset: uint64
	txna ApplicationArgs 4
	btoi

	// proof: string
	txna ApplicationArgs 3
	extract 2 0

	// hashedRoot: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 2 (hashedRoot) for verifyAsset must be a byte[32]
	assert

	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 3 (address) for verifyAsset must be a address
	assert

	// execute verifyAsset(address,byte[32],string,uint64)bool
	callsub verifyAsset
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// verifyAsset(address: Address, hashedRoot: bytes32, proof: string, verifyingAsset: AssetID): boolean
//
// verify an inclusion in a merkle tree & ensure the merkle tree
// is in reference to a group of asset IDs
//
// @param address the address of the merkle tree root creator
// @param hashedRoot the sha256'd 32 byte merkle tree root
// @param proof the proof for the asset
// @param verifyingAsset the `assetID` we're checking against the merkle root
// @returns a boolean indicating the check passed or failed
verifyAsset:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/MetaMerkles.algo.ts:141
	// rootKey: RootKey = { address: address, root: hashedRoot }
	frame_dig -1 // address: Address
	frame_dig -2 // hashedRoot: bytes32
	concat
	frame_bury 0 // rootKey: RootKey

	// contracts/MetaMerkles.algo.ts:142
	// assert(this.roots(rootKey).exists)
	frame_dig 0 // rootKey: RootKey
	box_len
	swap
	pop
	assert

	// contracts/MetaMerkles.algo.ts:144
	// type = btoi(this.read(address, hashedRoot, 'type'))
	byte 0x74797065 // "type"
	frame_dig -2 // hashedRoot: bytes32
	frame_dig -1 // address: Address
	callsub read
	btoi
	frame_bury 1 // type: uint64

	// contracts/MetaMerkles.algo.ts:145
	// assert(type === RootTypeAsset, 'mtree is not type AssetID or Mixed')
	frame_dig 1 // type: uint64
	int 1
	==

	// mtree is not type AssetID or Mixed
	assert

	// contracts/MetaMerkles.algo.ts:147
	// hash: string = sha256(itob(verifyingAsset)) as string
	frame_dig -4 // verifyingAsset: AssetID
	itob
	sha256
	frame_bury 2 // hash: string

	// contracts/MetaMerkles.algo.ts:149
	// return this.verify(hashedRoot, proof, hash);
	frame_dig 2 // hash: string
	frame_dig -3 // proof: string
	frame_dig -2 // hashedRoot: bytes32
	callsub verify

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// verifyAddress(address,byte[32],string,address)bool
*abi_route_verifyAddress:
	// The ABI return prefix
	byte 0x151f7c75

	// verifyingAddress: address
	txna ApplicationArgs 4
	dup
	len
	int 32
	==

	// argument 0 (verifyingAddress) for verifyAddress must be a address
	assert

	// proof: string
	txna ApplicationArgs 3
	extract 2 0

	// hashedRoot: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 2 (hashedRoot) for verifyAddress must be a byte[32]
	assert

	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 3 (address) for verifyAddress must be a address
	assert

	// execute verifyAddress(address,byte[32],string,address)bool
	callsub verifyAddress
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// verifyAddress(address: Address, hashedRoot: bytes32, proof: string, verifyingAddress: Address): boolean
//
// verify an inclusion in a merkle tree & ensure the merkle tree
// is in reference to a group of addresses
//
// @param address the address of the merkle tree root creator
// @param hashedRoot the sha256'd 32 byte merkle tree root
// @param proof the proof for the address
// @param verifyingAddress the `Address` we're checking against the merkle root
// @returns a boolean indicating the check passed or failed
verifyAddress:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/MetaMerkles.algo.ts:168
	// rootKey: RootKey = { address: address, root: hashedRoot }
	frame_dig -1 // address: Address
	frame_dig -2 // hashedRoot: bytes32
	concat
	frame_bury 0 // rootKey: RootKey

	// contracts/MetaMerkles.algo.ts:169
	// assert(this.roots(rootKey).exists)
	frame_dig 0 // rootKey: RootKey
	box_len
	swap
	pop
	assert

	// contracts/MetaMerkles.algo.ts:171
	// type = btoi(this.read(address, hashedRoot, 'type'))
	byte 0x74797065 // "type"
	frame_dig -2 // hashedRoot: bytes32
	frame_dig -1 // address: Address
	callsub read
	btoi
	frame_bury 1 // type: uint64

	// contracts/MetaMerkles.algo.ts:172
	// assert(type === RootTypeAddress, 'mtree is not type Address or Mixed')
	frame_dig 1 // type: uint64
	int 2
	==

	// mtree is not type Address or Mixed
	assert

	// contracts/MetaMerkles.algo.ts:174
	// hash: string = sha256(verifyingAddress) as string
	frame_dig -4 // verifyingAddress: Address
	sha256
	frame_bury 2 // hash: string

	// contracts/MetaMerkles.algo.ts:176
	// return this.verify(hashedRoot, proof, hash);
	frame_dig 2 // hash: string
	frame_dig -3 // proof: string
	frame_dig -2 // hashedRoot: bytes32
	callsub verify

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// verifyApp(address,byte[32],string,uint64)bool
*abi_route_verifyApp:
	// The ABI return prefix
	byte 0x151f7c75

	// verifyingApp: uint64
	txna ApplicationArgs 4
	btoi

	// proof: string
	txna ApplicationArgs 3
	extract 2 0

	// hashedRoot: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 2 (hashedRoot) for verifyApp must be a byte[32]
	assert

	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 3 (address) for verifyApp must be a address
	assert

	// execute verifyApp(address,byte[32],string,uint64)bool
	callsub verifyApp
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// verifyApp(address: Address, hashedRoot: bytes32, proof: string, verifyingApp: AppID): boolean
//
// verify an inclusion in a merkle tree & ensure the merkle tree
// is in reference to a group of appIDs
//
// @param address the address of the merkle tree root creator
// @param hashedRoot the sha256'd 32 byte merkle tree root
// @param proof the proof for the app
// @param verifyingApp the `AppID` we're checking against the merkle root
// @returns a boolean indicating the check passed or failed
verifyApp:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/MetaMerkles.algo.ts:195
	// rootKey: RootKey = { address: address, root: hashedRoot }
	frame_dig -1 // address: Address
	frame_dig -2 // hashedRoot: bytes32
	concat
	frame_bury 0 // rootKey: RootKey

	// contracts/MetaMerkles.algo.ts:196
	// assert(this.roots(rootKey).exists)
	frame_dig 0 // rootKey: RootKey
	box_len
	swap
	pop
	assert

	// contracts/MetaMerkles.algo.ts:198
	// type = btoi(this.read(address, hashedRoot, 'type'))
	byte 0x74797065 // "type"
	frame_dig -2 // hashedRoot: bytes32
	frame_dig -1 // address: Address
	callsub read
	btoi
	frame_bury 1 // type: uint64

	// contracts/MetaMerkles.algo.ts:199
	// assert((type === RootTypeApp), 'mtree is not type AppID or Mixed')
	frame_dig 1 // type: uint64
	int 3
	==

	// mtree is not type AppID or Mixed
	assert

	// contracts/MetaMerkles.algo.ts:201
	// hash: string = sha256(itob(verifyingApp)) as string
	frame_dig -4 // verifyingApp: AppID
	itob
	sha256
	frame_bury 2 // hash: string

	// contracts/MetaMerkles.algo.ts:203
	// return this.verify(hashedRoot, proof, hash);
	frame_dig 2 // hash: string
	frame_dig -3 // proof: string
	frame_dig -2 // hashedRoot: bytes32
	callsub verify

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// verify(byte[32],string,string)bool
*abi_route_verify:
	// The ABI return prefix
	byte 0x151f7c75

	// hash: string
	txna ApplicationArgs 3
	extract 2 0

	// proof: string
	txna ApplicationArgs 2
	extract 2 0

	// hashedRoot: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (hashedRoot) for verify must be a byte[32]
	assert

	// execute verify(byte[32],string,string)bool
	callsub verify
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// verify(hashedRoot: bytes32, proof: string, hash: string): boolean
//
// verify an inclusion in a merkle tree
//
// @param hashedRoot the sha256'd 32 byte merkle tree root
// @param proof the proof the hash is included
// @param hash the hash of the info being verified
// @returns a boolean indicating the check passed or failed
verify:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/MetaMerkles.algo.ts:215
	// for (let i = 0; i < proof.length; i + hashLength)
	int 0
	frame_bury 0 // i: uint64

*for_0:
	// contracts/MetaMerkles.algo.ts:215
	// i < proof.length
	frame_dig 0 // i: uint64
	frame_dig -2 // proof: string
	len
	<
	bz *for_0_end

	// contracts/MetaMerkles.algo.ts:216
	// hash = this.hash(hash, extract3(proof, i, hashLength))
	frame_dig -2 // proof: string
	frame_dig 0 // i: uint64
	int 32
	extract3
	frame_dig -3 // hash: string
	callsub hash
	frame_bury -3 // hash: string

*for_0_continue:
	// contracts/MetaMerkles.algo.ts:215
	// i + hashLength
	frame_dig 0 // i: uint64
	int 32
	+
	b *for_0

*for_0_end:
	// contracts/MetaMerkles.algo.ts:219
	// return hashedRoot === sha256(hash);
	frame_dig -1 // hashedRoot: bytes32
	frame_dig -3 // hash: string
	sha256
	==

	// set the subroutine return value
	frame_bury 0
	retsub

// read(address,byte[32],string)string
*abi_route_read:
	// The ABI return prefix
	byte 0x151f7c75

	// key: string
	txna ApplicationArgs 3
	extract 2 0

	// hashedRoot: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (hashedRoot) for read must be a byte[32]
	assert

	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (address) for read must be a address
	assert

	// execute read(address,byte[32],string)string
	callsub read
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// read(address: Address, hashedRoot: bytes32, key: string): string
//
// fetch a metadata property
//
// @param address the address of the merkle tree root creator
// @param hashedRoot the sha256'd 32 byte merkle tree root
// @param key the metadata key eg. `Royalty`
// @returns the value set eg. `5` encoded as a bytestring for 5%
read:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/MetaMerkles.algo.ts:231
	// dataKey: DataKey = this.getDataKey(address, hashedRoot, key)
	frame_dig -3 // key: string
	frame_dig -2 // hashedRoot: bytes32
	frame_dig -1 // address: Address
	callsub getDataKey
	frame_bury 0 // dataKey: DataKey

	// contracts/MetaMerkles.algo.ts:232
	// assert(this.data(dataKey).exists)
	frame_dig 0 // dataKey: DataKey
	box_len
	swap
	pop
	assert

	// contracts/MetaMerkles.algo.ts:233
	// return this.data(dataKey).value
	frame_dig 0 // dataKey: DataKey
	box_get

	// box value does not exist: this.data(dataKey).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// hash(a: string, b: string): string
hash:
	proto 2 1

	// contracts/MetaMerkles.algo.ts:238
	// return sha256(btoi(a) < btoi(b) ? a + b : b + a) as string;
	frame_dig -1 // a: string
	btoi
	frame_dig -2 // b: string
	btoi
	<
	bz *ternary0_false
	frame_dig -1 // a: string
	frame_dig -2 // b: string
	concat
	b *ternary0_end

*ternary0_false:
	frame_dig -2 // b: string
	frame_dig -1 // a: string
	concat

*ternary0_end:
	sha256
	retsub

// getBoxCreateMinBalance(a: uint64, b: uint64): uint64
getBoxCreateMinBalance:
	proto 2 1

	// contracts/MetaMerkles.algo.ts:242
	// return 25_00 + (400 * (a + b))
	int 25_00
	int 400
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	*
	+
	retsub

// getDataKey(address: Address, root: bytes32, key: string): DataKey
getDataKey:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/MetaMerkles.algo.ts:246
	// truncatedAddress = extract3(address, 0, 16) as bytes16
	frame_dig -1 // address: Address
	extract 0 16
	byte 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	byte 0x
	b==
	assert
	extract 0 16
	frame_bury 0 // truncatedAddress: byte[16]

	// contracts/MetaMerkles.algo.ts:247
	// truncatedRoot = extract3(root, 0, 16) as bytes16
	frame_dig -2 // root: bytes32
	extract 0 16
	byte 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	byte 0x
	b==
	assert
	extract 0 16
	frame_bury 1 // truncatedRoot: byte[16]

	// contracts/MetaMerkles.algo.ts:249
	// return { address: truncatedAddress, root: truncatedRoot, key: key };
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig 1 // truncatedRoot: byte[16]
	callsub *process_static_tuple_element
	frame_dig -3 // key: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "addRoot(pay,byte[32],uint64)void"
	method "deleteRoot(byte[32])void"
	method "addData(pay,byte[32],string,string)void"
	method "deleteData(byte[32],string)void"
	method "verifyAsset(address,byte[32],string,uint64)bool"
	method "verifyAddress(address,byte[32],string,address)bool"
	method "verifyApp(address,byte[32],string,uint64)bool"
	method "verify(byte[32],string,string)bool"
	method "read(address,byte[32],string)string"
	txna ApplicationArgs 0
	match *abi_route_addRoot *abi_route_deleteRoot *abi_route_addData *abi_route_deleteData *abi_route_verifyAsset *abi_route_verifyAddress *abi_route_verifyApp *abi_route_verify *abi_route_read

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub